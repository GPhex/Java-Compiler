options {
    STATIC = false;
}

PARSER_BEGIN(Parser)

import ast.JasvaASTNode;
import ast.arithmetic.*;
import ast.block.*;
import ast.logical.*;
import ast.relational.*;
import ast.specific.*;
import ast.types.*;
import ast.variable.*;

import compilation.*;
import codeGeneration.environment.LinkedEnvironment;
import codeGeneration.programGeneration.*;
import compilation.fileGeneration.CachedProgramGenerator;
import types.*;
import util.Pair;
import values.Value;

import java.util.List;
import java.util.LinkedList;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class Parser {

    private static final String EXTENSION = ".jsv";
    private static final String INTERPRET_FLAG = "-i";
    private static final String FILE_FLAG = "-f";
    private static final String AST_FLAG = "-ast";

    public static void main(String[] args) {
        try {
            boolean interpretFlag = false;
            boolean printASTFlag = false;
            String fileName = null;
            InputStream readFrom = System.in;

            int i = 0;
            while (i < args.length & i < 4) {
                switch (args[i++]) {
                    case INTERPRET_FLAG:
                        interpretFlag = true;
                        break;
                    case AST_FLAG:
                        printASTFlag = true;
                        break;
                    case FILE_FLAG:
                        if (i < args.length && (fileName = args[i++]).endsWith(EXTENSION))
                            readFrom = new FileInputStream(fileName);
                        else {
                            System.err.println("-f requires a valid " + EXTENSION +  " filename");
                            throw new IllegalStateException();
                        }
                        break;
                    default:
                        throw new IllegalStateException();
                }
            }
            if (readFrom == System.in) interpretFlag = true;
            if(printASTFlag)
                System.out.println("Printing Abstract Syntax Tree");
            if(interpretFlag)
                Parser.interpretMode(readFrom, printASTFlag);
            else
                Parser.compilerMode(fileName, readFrom, printASTFlag);

        } catch (IOException e) {
            System.err.println("Could not load the file.");
            printHelp();
        } catch (IllegalStateException e) {
            System.err.println("Bad argument.");
            printHelp();
        }
    }

    private static void interpretMode(final InputStream readFrom, final boolean printAST) {
        do {
            Parser parser = new Parser(readFrom);
            try {
                JasvaASTNode node = parser.Start();
                if(printAST) node.printNode("", "");
                System.out.println("Output> " + node.evaluate(new LinkedEnvironment<Value<?>>(null)));
            }
            catch (ParseException e) {
                System.err.println("Syntax error!");
            }
            catch (Exception e) {
                System.err.println(e.getMessage());
            }
        } while(readFrom == System.in);
    }

    private static void compilerMode(final String fileName, final InputStream readFrom, final boolean printAST) {
        final String outFileName = fileName.substring(fileName.lastIndexOf("/") + 1, fileName.lastIndexOf("."));
        Parser parser = new Parser(readFrom);
        try {
            JasvaASTNode node = parser.Start();
            node.typeCheck(new LinkedEnvironment<Type>(null));
            ProgramGenerator<JasminCompiler> programGenerator = new CachedProgramGenerator(outFileName, "j");
            CompiledClass<JasminCompiler> mainClass = programGenerator.getClass(outFileName);
            MethodBuilder<JasminCompiler> mainMethod = mainClass.addMethod("main", BaseTypes.VOID, Modifiers.PUBLIC, Modifiers.STATIC);
            mainMethod.addParam("args", CompilerType.array(BaseTypes.STRING));
            JasminCompiler compiler = mainMethod.getCompiler();
            compiler.startStaticLinker();
            if(printAST)
                node.printNode("", "");
            System.out.println("Compiling " + fileName);
            node.compile(mainClass, compiler, new LinkedEnvironment<Pair<Integer, String>>(null));
            programGenerator.generateFiles();
        }
        catch (ParseException e) {
            System.err.println("Syntax error!");
        }
        catch (IOException e) {
            System.err.println("Could not generate files");
        }
        catch(Exception e) {
            System.err.println(e.getMessage());
        }
    }

    private static void printHelp() {
        System.out.println("Usage: java -jar Jasva.jar [-i] [-f file] [-ast]");
        System.out.println("-f file: compiles the provided file");
        System.out.println("-i: force interpreter mode. If a valid -f flag is present, interprets given file and exits");
        System.out.println("-ast: prints the syntax tree associated with the program");
    }
}

PARSER_END(Parser)

SKIP: {
    " "
  | "\n"
  | "\t"
  | "\r"
}

// Reseved keywords
TOKEN:
{
  <DEF: "def"    >
| <IN : "in"     >
| <IF : "if"     >
| <THN: "then"   >
| <ELS: "else"   >
| <WHL: "while"  >
| <DO : "do"     >
| <NEW: "new"    >
| <END: "end"    >
| <INT: "int"    >
| <BOL: "bool"   >
| <REF: "ref"    >
| <PRT: "print"  >
| <PRL: "println">
}

// Operator tokens
TOKEN:
{
  <MO_POS: "+" >
| <MO_NEG: "-" >
| <MO_PRO: "*" >
| <MO_DIV: "/" >
| <MO_MOD: "%" >
| <DEFINE: "=" >
| <ASSIGN: ":=">
| <DEREF : "!" >
| <CMP_EQ: "==">
| <CMP_LT: "<" >
| <CMP_LE: "<=">
| <CMP_GT: ">" >
| <CMP_GE: ">=">
| <LO_OR : "||">
| <LO_AND: "&&">
| <LO_NOT: "~" >
}

// Misc tokens
TOKEN:
{
  <TERM : ";;">
| <DLMT : ";" >
| <COM  : "," >
| <L_PAR: "(" >
| <R_PAR: ")" >
| <COLN : ":" >
}

// Literals
TOKEN:
{
  <INTEGER_LITERAL: <DECIMAL_LITERAL> (["l", "L"])? >
| <#DECIMAL_LITERAL: (["0"-"9"])+>
| <BOOLEAN_LITERAL: "true"|"false">
}

// Identifiers
TOKEN:
{
  <IDENTIFIER: <LETTER> (<DECIMAL> | <LETTER>)*>
| <#LETTER: ["a"-"z","A"-"Z","_","$"]>
| <#DECIMAL: ["0"-"9"]>
}

JasvaASTNode Start():
{JasvaASTNode statements;}
{
    statements = CompoundStatement() <TERM>
    { return statements; }
}

JasvaASTNode CompoundStatement():
{JasvaASTNode leftUnit, rightUnit;}
{
    leftUnit = TranslationUnit() (<DLMT> rightUnit = TranslationUnit()
    {leftUnit = new ASTCompoundNode(leftUnit, rightUnit);})*
    { return leftUnit; }
}

JasvaASTNode TranslationUnit():
{JasvaASTNode leftExp, rightExp;}
{
    leftExp = LogicORExpression()
    (LOOKAHEAD(2) <ASSIGN> rightExp = LogicORExpression() {leftExp = new ASTAssignNode(leftExp, rightExp);})?
    { return leftExp; }
}

JasvaASTNode LogicORExpression():
{JasvaASTNode l_exp, r_exp;}
{
  l_exp = LogicANDExpression() (LOOKAHEAD(2) <LO_OR> r_exp = LogicANDExpression() {l_exp = new ASTOrNode(l_exp, r_exp);})*
  {return l_exp;}
}

JasvaASTNode LogicANDExpression():
{JasvaASTNode l_exp, r_exp;}
{
  l_exp = ComparisonExpression() (LOOKAHEAD(2) <LO_AND> r_exp = ComparisonExpression() {l_exp = new ASTAndNode(l_exp, r_exp);})*
  {return l_exp;}
}

JasvaASTNode ComparisonExpression():
{JasvaASTNode l_exp, r_exp;
Token op;}
{
  l_exp = RelationalExpression() [LOOKAHEAD(2) <CMP_EQ> r_exp = RelationalExpression()
{l_exp = new ASTEqualsNode(l_exp, r_exp);}]
  {return l_exp;}
}

JasvaASTNode RelationalExpression():
{JasvaASTNode l_exp, r_exp;
Token op;}
{
  l_exp = AdditiveExpression() [
  LOOKAHEAD(2)
   ((op = <CMP_LT> r_exp = AdditiveExpression() {l_exp = new ASTLessThanNode(l_exp, r_exp);})
  | (op = <CMP_LE> r_exp = AdditiveExpression() {l_exp = new ASTLessEqNode(l_exp, r_exp);})
  | (op = <CMP_GT> r_exp = AdditiveExpression() {l_exp = new ASTGreatThanNode(l_exp, r_exp);})
  | (op = <CMP_GE> r_exp = AdditiveExpression() {l_exp = new ASTGreatEqNode(l_exp, r_exp);}))]
  {return l_exp;}
}

JasvaASTNode AdditiveExpression():
{JasvaASTNode l_exp, r_exp;
Token op;}
{
  l_exp = MultiplicativeExpression() (LOOKAHEAD(2) (op = <MO_POS> | op = <MO_NEG>) r_exp = MultiplicativeExpression()
{switch(op.kind) {
  case MO_POS: l_exp = new ASTAddNode(l_exp, r_exp); break;
  case MO_NEG: l_exp = new ASTSubNode(l_exp, r_exp); break;
}
})*
  {return l_exp;}
}

JasvaASTNode MultiplicativeExpression():
{JasvaASTNode l_exp, r_exp;
Token op;}
{
  l_exp = UnaryExpression() (LOOKAHEAD(2) (op = <MO_PRO> | op = <MO_DIV> | op = <MO_MOD>) r_exp = UnaryExpression()
{switch(op.kind) {
  case MO_PRO: l_exp = new ASTMulNode(l_exp, r_exp); break;
  case MO_DIV: l_exp = new ASTDivNode(l_exp, r_exp); break;
  case MO_MOD: l_exp = new ASTModNode(l_exp, r_exp); break;
}
})*
  {return l_exp;}
}

JasvaASTNode UnaryExpression():
{JasvaASTNode exp;}
{
  ( <MO_NEG> exp = UnaryExpression() {exp = new ASTNegNode(exp);}
  | <MO_POS> exp = UnaryExpression() {exp = new ASTPosNode(exp);}
  | <LO_NOT> exp = UnaryExpression() {exp = new ASTNotNode(exp);}
  | <L_PAR> exp = CompoundStatement() <R_PAR>
  | exp = PrimaryExpression())
  {return exp;}
}

JasvaASTNode PrimaryExpression():
{JasvaASTNode exp;}
{
  ( exp = Literal()
  | exp = Var()
  | exp = ScopeExpression()
  | exp = ReferenceExpression()
  | exp = BranchingExpression()
  | exp = IterationExpression()
  | exp = PrintExpression())
  {return exp;}
}

JasvaASTNode Literal():
{Token value;}
{
    value = <INTEGER_LITERAL> { return new ASTIntNode(Integer.parseInt(value.image));}
  | value = <BOOLEAN_LITERAL> { return new ASTBoolNode(Boolean.parseBoolean(value.image));}
}

JasvaASTNode Var():
{Token value;
JasvaASTNode node;}
{
    value = <IDENTIFIER> {node = new ASTIdNode(value.image);}
    { return node; }
}

JasvaASTNode ScopeExpression():
{List<ASTDefineNode> defines;
JasvaASTNode scope;}
{
  <DEF> defines = DefinitionList() <IN> scope = CompoundStatement() <END>
  {return new ASTLetNode(defines, scope);}
}

List<ASTDefineNode> DefinitionList():
{List<ASTDefineNode> defs = new LinkedList<ASTDefineNode>();
ASTDefineNode cur_def;}
{
  cur_def = Definition() {defs.add(cur_def);} ([<COM>] cur_def = Definition() {defs.add(cur_def);})*
  {return defs;}
}

ASTDefineNode Definition():
{Token varID;
Type type;
JasvaASTNode varVal;}
{
  varID = <IDENTIFIER> <COLN> type = ExpType() <DEFINE> varVal = CompoundStatement()
  {return new ASTDefineNode(varID.image, type, varVal);}
}

Type ExpType():
{Type innerType;}
{
    <INT> { return new IntType(); }
  | <BOL> { return new BoolType(); }
  | <REF> innerType = ExpType() { return new RefType(innerType); }
}

JasvaASTNode ReferenceExpression():
{JasvaASTNode exp;}
{
  ( <NEW> exp = PrimaryExpression() {exp = new ASTNewRefNode(exp);}
  | <DEREF> exp = PrimaryExpression() {exp = new ASTDerefNode(exp);})
  {return exp;}
}

JasvaASTNode BranchingExpression():
{JasvaASTNode cond, t_block, f_block = null;}
{
  <IF> cond = CompoundStatement() <THN> t_block = CompoundStatement() [<ELS> f_block = CompoundStatement()] <END>
  {return new ASTIfNode(cond, t_block, f_block);}
}

JasvaASTNode IterationExpression():
{JasvaASTNode cond, block;}
{
  <WHL> cond = CompoundStatement() <DO> block = CompoundStatement() <END>
  {return new ASTWhileNode(cond, block);}
}

JasvaASTNode PrintExpression():
{JasvaASTNode node = null;}
{
   (<PRL> [LOOKAHEAD(1) node = TranslationUnit()] { return new ASTPrintNode(node, true);})
 | (<PRT> node = TranslationUnit() { return new ASTPrintNode(node, false);})
}
